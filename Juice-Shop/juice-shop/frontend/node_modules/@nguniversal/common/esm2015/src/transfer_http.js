/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HTTP_INTERCEPTORS, HttpHeaders, HttpResponse } from '@angular/common/http';
import { ApplicationRef, Injectable, NgModule } from '@angular/core';
import { BrowserTransferStateModule, TransferState, makeStateKey } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { filter, take, tap } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/platform-browser';
function getHeadersMap(headers) {
    const headersMap = {};
    for (const key of headers.keys()) {
        headersMap[key] = headers.getAll(key);
    }
    return headersMap;
}
export class TransferHttpCacheInterceptor {
    constructor(appRef, transferState) {
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        // tslint:disable-next-line: no-floating-promises
        appRef.isStable
            .pipe(filter((isStable) => isStable), take(1)).toPromise()
            .then(() => { this.isCacheActive = false; });
    }
    invalidateCacheEntry(url) {
        Object.keys(this.transferState['store'])
            .forEach(key => key.includes(url) ? this.transferState.remove(makeStateKey(key)) : null);
    }
    makeCacheKey(method, url, params) {
        // make the params encoded same as a url so it's easy to identify
        const encodedParams = params.keys().sort().map(k => `${k}=${params.get(k)}`).join('&');
        const key = (method === 'GET' ? 'G.' : 'H.') + url + '?' + encodedParams;
        return makeStateKey(key);
    }
    intercept(req, next) {
        // Stop using the cache if there is a mutating call.
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            this.isCacheActive = false;
            this.invalidateCacheEntry(req.url);
        }
        if (!this.isCacheActive) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        const storeKey = this.makeCacheKey(req.method, req.url, req.params);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            const response = this.transferState.get(storeKey, {});
            return observableOf(new HttpResponse({
                body: response.body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            const httpEvent = next.handle(req);
            return httpEvent
                .pipe(tap((event) => {
                if (event instanceof HttpResponse) {
                    this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: event.url || '',
                    });
                }
            }));
        }
    }
}
TransferHttpCacheInterceptor.ɵfac = function TransferHttpCacheInterceptor_Factory(t) { return new (t || TransferHttpCacheInterceptor)(ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc1.TransferState)); };
TransferHttpCacheInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TransferHttpCacheInterceptor, factory: TransferHttpCacheInterceptor.ɵfac });
TransferHttpCacheInterceptor.ctorParameters = () => [
    { type: ApplicationRef },
    { type: TransferState }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TransferHttpCacheInterceptor, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ApplicationRef }, { type: ɵngcc1.TransferState }]; }, null); })();
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
export class TransferHttpCacheModule {
}
TransferHttpCacheModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TransferHttpCacheModule });
TransferHttpCacheModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TransferHttpCacheModule_Factory(t) { return new (t || TransferHttpCacheModule)(); }, providers: [
        TransferHttpCacheInterceptor,
        { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
    ], imports: [[BrowserTransferStateModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TransferHttpCacheModule, { imports: function () { return [BrowserTransferStateModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TransferHttpCacheModule, [{
        type: NgModule,
        args: [{
                imports: [BrowserTransferStateModule],
                providers: [
                    TransferHttpCacheInterceptor,
                    { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                ]
            }]
    }], null, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfaHR0cC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbW9kdWxlcy9jb21tb24vc3JjL3RyYW5zZmVyX2h0dHAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILE9BQU8sRUFDTCxpQkFBaUIsRUFHakIsV0FBVyxFQUlYLFlBQVksRUFDYixNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQ0wsMEJBQTBCLEVBRTFCLGFBQWEsRUFDYixZQUFZLEVBQ2IsTUFBTSwyQkFBMkIsQ0FBQztBQUNuQyxPQUFPLEVBQWMsRUFBRSxJQUFJLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBVW5ELFNBQVMsYUFBYSxDQUFDLE9BQW9CO0FBQzNDLElBQUUsTUFBTSxVQUFVLEdBQW9DLEVBQUUsQ0FBQztBQUN6RCxJQUFFLEtBQUssTUFBTSxHQUFHLElBQUksT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFO0FBQ3BDLFFBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDMUMsS0FBRztBQUNILElBQ0UsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUdELE1BQU0sT0FBTyw0QkFBNEI7QUFBRyxJQWlCMUMsWUFBWSxNQUFzQixFQUFVLGFBQTRCO0FBQzFFLFFBRDhDLGtCQUFhLEdBQWIsYUFBYSxDQUFlO0FBQUMsUUFmakUsa0JBQWEsR0FBRyxJQUFJLENBQUM7QUFDL0IsUUFlSSwwRkFBMEY7QUFDOUYsUUFBSSxZQUFZO0FBQ2hCLFFBQUksaURBQWlEO0FBQ3JELFFBQUks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ZUFDRjs7Ozs7Ozs7Ozs7OzBCQUNJO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7XG4gIEhUVFBfSU5URVJDRVBUT1JTLFxuICBIdHRwRXZlbnQsXG4gIEh0dHBIYW5kbGVyLFxuICBIdHRwSGVhZGVycyxcbiAgSHR0cEludGVyY2VwdG9yLFxuICBIdHRwUGFyYW1zLFxuICBIdHRwUmVxdWVzdCxcbiAgSHR0cFJlc3BvbnNlXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uUmVmLCBJbmplY3RhYmxlLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQnJvd3NlclRyYW5zZmVyU3RhdGVNb2R1bGUsXG4gIFN0YXRlS2V5LFxuICBUcmFuc2ZlclN0YXRlLFxuICBtYWtlU3RhdGVLZXlcbn0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiBhcyBvYnNlcnZhYmxlT2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgdGFrZSwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZmVySHR0cFJlc3BvbnNlIHtcbiAgYm9keT86IGFueSB8IG51bGw7XG4gIGhlYWRlcnM/OiB7W2s6IHN0cmluZ106IHN0cmluZ1tdfTtcbiAgc3RhdHVzPzogbnVtYmVyO1xuICBzdGF0dXNUZXh0Pzogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGdldEhlYWRlcnNNYXAoaGVhZGVyczogSHR0cEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVyc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nW10gfCBudWxsPiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBoZWFkZXJzLmtleXMoKSkge1xuICAgIGhlYWRlcnNNYXBba2V5XSA9IGhlYWRlcnMuZ2V0QWxsKGtleSk7XG4gIH1cblxuICByZXR1cm4gaGVhZGVyc01hcDtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRyYW5zZmVySHR0cENhY2hlSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuXG4gIHByaXZhdGUgaXNDYWNoZUFjdGl2ZSA9IHRydWU7XG5cbiAgcHJpdmF0ZSBpbnZhbGlkYXRlQ2FjaGVFbnRyeSh1cmw6IHN0cmluZykge1xuICAgIE9iamVjdC5rZXlzKHRoaXMudHJhbnNmZXJTdGF0ZVsnc3RvcmUnXSlcbiAgICAgIC5mb3JFYWNoKGtleSA9PiBrZXkuaW5jbHVkZXModXJsKSA/IHRoaXMudHJhbnNmZXJTdGF0ZS5yZW1vdmUobWFrZVN0YXRlS2V5KGtleSkpIDogbnVsbCk7XG4gIH1cblxuICBwcml2YXRlIG1ha2VDYWNoZUtleShtZXRob2Q6IHN0cmluZywgdXJsOiBzdHJpbmcsIHBhcmFtczogSHR0cFBhcmFtcyk6IFN0YXRlS2V5PHN0cmluZz4ge1xuICAgIC8vIG1ha2UgdGhlIHBhcmFtcyBlbmNvZGVkIHNhbWUgYXMgYSB1cmwgc28gaXQncyBlYXN5IHRvIGlkZW50aWZ5XG4gICAgY29uc3QgZW5jb2RlZFBhcmFtcyA9IHBhcmFtcy5rZXlzKCkuc29ydCgpLm1hcChrID0+IGAke2t9PSR7cGFyYW1zLmdldChrKX1gKS5qb2luKCcmJyk7XG4gICAgY29uc3Qga2V5ID0gKG1ldGhvZCA9PT0gJ0dFVCcgPyAnRy4nIDogJ0guJykgKyB1cmwgKyAnPycgKyBlbmNvZGVkUGFyYW1zO1xuXG4gICAgcmV0dXJuIG1ha2VTdGF0ZUtleTxUcmFuc2Zlckh0dHBSZXNwb25zZT4oa2V5KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFwcFJlZjogQXBwbGljYXRpb25SZWYsIHByaXZhdGUgdHJhbnNmZXJTdGF0ZTogVHJhbnNmZXJTdGF0ZSkge1xuICAgIC8vIFN0b3AgdXNpbmcgdGhlIGNhY2hlIGlmIHRoZSBhcHBsaWNhdGlvbiBoYXMgc3RhYmlsaXplZCwgaW5kaWNhdGluZyBpbml0aWFsIHJlbmRlcmluZyBpc1xuICAgIC8vIGNvbXBsZXRlLlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICBhcHBSZWYuaXNTdGFibGVcbiAgICAgIC5waXBlKFxuICAgICAgICBmaWx0ZXIoKGlzU3RhYmxlOiBib29sZWFuKSA9PiBpc1N0YWJsZSksXG4gICAgICAgIHRha2UoMSlcbiAgICAgICkudG9Qcm9taXNlKClcbiAgICAgIC50aGVuKCgpID0+IHsgdGhpcy5pc0NhY2hlQWN0aXZlID0gZmFsc2U7IH0pO1xuICB9XG5cbiAgaW50ZXJjZXB0KHJlcTogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XG4gICAgLy8gU3RvcCB1c2luZyB0aGUgY2FjaGUgaWYgdGhlcmUgaXMgYSBtdXRhdGluZyBjYWxsLlxuICAgIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJyAmJiByZXEubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgIHRoaXMuaXNDYWNoZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlQ2FjaGVFbnRyeShyZXEudXJsKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNDYWNoZUFjdGl2ZSkge1xuICAgICAgLy8gQ2FjaGUgaXMgbm8gbG9uZ2VyIGFjdGl2ZS4gUGFzcyB0aGUgcmVxdWVzdCB0aHJvdWdoLlxuICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmVLZXkgPSB0aGlzLm1ha2VDYWNoZUtleShyZXEubWV0aG9kLCByZXEudXJsLCByZXEucGFyYW1zKTtcblxuICAgIGlmICh0aGlzLnRyYW5zZmVyU3RhdGUuaGFzS2V5KHN0b3JlS2V5KSkge1xuICAgICAgLy8gUmVxdWVzdCBmb3VuZCBpbiBjYWNoZS4gUmVzcG9uZCB1c2luZyBpdC5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy50cmFuc2ZlclN0YXRlLmdldChzdG9yZUtleSwge30gYXMgVHJhbnNmZXJIdHRwUmVzcG9uc2UpO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKG5ldyBIdHRwUmVzcG9uc2U8YW55Pih7XG4gICAgICAgIGJvZHk6IHJlc3BvbnNlLmJvZHksXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIdHRwSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXF1ZXN0IG5vdCBmb3VuZCBpbiBjYWNoZS4gTWFrZSB0aGUgcmVxdWVzdCBhbmQgY2FjaGUgaXQuXG4gICAgICBjb25zdCBodHRwRXZlbnQgPSBuZXh0LmhhbmRsZShyZXEpO1xuXG4gICAgICByZXR1cm4gaHR0cEV2ZW50XG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIHRhcCgoZXZlbnQ6IEh0dHBFdmVudDx1bmtub3duPikgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNmZXJTdGF0ZS5zZXQoc3RvcmVLZXksIHtcbiAgICAgICAgICAgICAgICBib2R5OiBldmVudC5ib2R5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnNNYXAoZXZlbnQuaGVhZGVycyksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBldmVudC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogZXZlbnQuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICB1cmw6IGV2ZW50LnVybCB8fCAnJyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBOZ01vZHVsZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYFNlcnZlclRyYW5zZmVySHR0cENhY2hlTW9kdWxlYCB0byB0cmFuc2ZlciBjYWNoZWQgSFRUUFxuICogY2FsbHMgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgYXBwbGljYXRpb24uXG4gKi9cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZV0sXG4gIHByb3ZpZGVyczogW1xuICAgIFRyYW5zZmVySHR0cENhY2hlSW50ZXJjZXB0b3IsXG4gICAge3Byb3ZpZGU6IEhUVFBfSU5URVJDRVBUT1JTLCB1c2VFeGlzdGluZzogVHJhbnNmZXJIdHRwQ2FjaGVJbnRlcmNlcHRvciwgbXVsdGk6IHRydWV9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmFuc2Zlckh0dHBDYWNoZU1vZHVsZSB7fVxuIl19