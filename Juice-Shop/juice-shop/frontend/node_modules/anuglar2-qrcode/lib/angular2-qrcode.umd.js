(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),exports, require('@angular/core'), require('qrious')) :
	typeof define === 'function' && define.amd ? define(['@angular/core','exports', '@angular/core', 'qrious'], factory) :
	(factory(global.ng.core,(global['angular2-qrcode'] = global['angular2-qrcode'] || {}),global._angular_core,global.QRious));
}(this, (function (ɵngcc0,exports,_angular_core,QRious) { 'use strict';

QRious = 'default' in QRious ? QRious['default'] : QRious;

var QRCodeComponent = (function () {
    /**
     * @param {?} elementRef
     */
    function QRCodeComponent(elementRef) {
        this.elementRef = elementRef;
        this.background = 'white';
        this.backgroundAlpha = 1.0;
        this.foreground = 'black';
        this.foregroundAlpha = 1.0;
        this.level = 'L';
        this.mime = 'image/png';
        this.padding = null;
        this.size = 100;
        this.value = '';
        this.canvas = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    QRCodeComponent.prototype.ngOnChanges = function (changes) {
        if ('background' in changes ||
            'backgroundAlpha' in changes ||
            'foreground' in changes ||
            'foregroundAlpha' in changes ||
            'level' in changes ||
            'mime' in changes ||
            'padding' in changes ||
            'size' in changes ||
            'value' in changes ||
            'canvas' in changes) {
            this.generate();
        }
    };
    /**
     * @return {?}
     */
    QRCodeComponent.prototype.generate = function () {
        try {
            var /** @type {?} */ el = this.elementRef.nativeElement;
            el.innerHTML = '';
            var /** @type {?} */ qr = new QRious({
                background: this.background,
                backgroundAlpha: this.backgroundAlpha,
                foreground: this.foreground,
                foregroundAlpha: this.foregroundAlpha,
                level: this.level,
                mime: this.mime,
                padding: this.padding,
                size: this.size,
                value: this.value
            });
            if (this.canvas) {
                el.appendChild(qr.canvas);
            }
            else {
                el.appendChild(qr.image);
            }
        }
        catch (e) {
            console.error("Could not generate QR Code: " + e.message);
        }
    };
QRCodeComponent.ɵfac = function QRCodeComponent_Factory(t) { return new (t || QRCodeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
QRCodeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: QRCodeComponent, selectors: [["qr-code"]], inputs: { background: "background", backgroundAlpha: "backgroundAlpha", foreground: "foreground", foregroundAlpha: "foregroundAlpha", level: "level", mime: "mime", padding: "padding", size: "size", value: "value", canvas: "canvas" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function QRCodeComponent_Template(rf, ctx) { }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(QRCodeComponent, [{
        type: _angular_core.Component,
        args: [{
                moduleId: 'module.id',
                selector: 'qr-code',
                template: ""
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { background: [{
            type: _angular_core.Input
        }], backgroundAlpha: [{
            type: _angular_core.Input
        }], foreground: [{
            type: _angular_core.Input
        }], foregroundAlpha: [{
            type: _angular_core.Input
        }], level: [{
            type: _angular_core.Input
        }], mime: [{
            type: _angular_core.Input
        }], padding: [{
            type: _angular_core.Input
        }], size: [{
            type: _angular_core.Input
        }], value: [{
            type: _angular_core.Input
        }], canvas: [{
            type: _angular_core.Input
        }] }); })();
    return QRCodeComponent;
}());
/**
 * @nocollapse
 */
QRCodeComponent.ctorParameters = function () { return [
    { type: _angular_core.ElementRef, },
]; };
QRCodeComponent.propDecorators = {
    'background': [{ type: _angular_core.Input },],
    'backgroundAlpha': [{ type: _angular_core.Input },],
    'foreground': [{ type: _angular_core.Input },],
    'foregroundAlpha': [{ type: _angular_core.Input },],
    'level': [{ type: _angular_core.Input },],
    'mime': [{ type: _angular_core.Input },],
    'padding': [{ type: _angular_core.Input },],
    'size': [{ type: _angular_core.Input },],
    'value': [{ type: _angular_core.Input },],
    'canvas': [{ type: _angular_core.Input },],
};
var QRCodeModule = (function () {
    function QRCodeModule() {
    }
QRCodeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: QRCodeModule });
QRCodeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function QRCodeModule_Factory(t) { return new (t || QRCodeModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(QRCodeModule, { declarations: [QRCodeComponent], exports: [QRCodeComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(QRCodeModule, [{
        type: _angular_core.NgModule,
        args: [{
                exports: [QRCodeComponent],
                declarations: [QRCodeComponent]
            }]
    }], function () { return []; }, null); })();
    return QRCodeModule;
}());
/**
 * @nocollapse
 */
QRCodeModule.ctorParameters = function () { return []; };

/**
 * Generated bundle index. Do not edit.
 */

exports.QRCodeComponent = QRCodeComponent;
exports.QRCodeModule = QRCodeModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjItcXJjb2RlLnVtZC5qcyIsInNvdXJjZXMiOlsiYW5ndWxhcjItcXJjb2RlLnVtZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGlHQUF3RTtBQUN4RSxzRUFBc0Q7QUFDdEQseUJBQVU7QUFDViwwQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0EsS0FPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztnREFBSztBQUNMO0FBQ0EsS0FNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdxcmlvdXMnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAncXJpb3VzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbFsnYW5ndWxhcjItcXJjb2RlJ10gPSBnbG9iYWxbJ2FuZ3VsYXIyLXFyY29kZSddIHx8IHt9KSxnbG9iYWwuX2FuZ3VsYXJfY29yZSxnbG9iYWwuUVJpb3VzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlLFFSaW91cykgeyAndXNlIHN0cmljdCc7XG5cblFSaW91cyA9ICdkZWZhdWx0JyBpbiBRUmlvdXMgPyBRUmlvdXNbJ2RlZmF1bHQnXSA6IFFSaW91cztcblxudmFyIFFSQ29kZUNvbXBvbmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBRUkNvZGVDb21wb25lbnQoZWxlbWVudFJlZikge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gJ3doaXRlJztcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRBbHBoYSA9IDEuMDtcclxuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSAnYmxhY2snO1xyXG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZEFscGhhID0gMS4wO1xyXG4gICAgICAgIHRoaXMubGV2ZWwgPSAnTCc7XHJcbiAgICAgICAgdGhpcy5taW1lID0gJ2ltYWdlL3BuZyc7XHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNpemUgPSAxMDA7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUVJDb2RlQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKCdiYWNrZ3JvdW5kJyBpbiBjaGFuZ2VzIHx8XHJcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kQWxwaGEnIGluIGNoYW5nZXMgfHxcclxuICAgICAgICAgICAgJ2ZvcmVncm91bmQnIGluIGNoYW5nZXMgfHxcclxuICAgICAgICAgICAgJ2ZvcmVncm91bmRBbHBoYScgaW4gY2hhbmdlcyB8fFxyXG4gICAgICAgICAgICAnbGV2ZWwnIGluIGNoYW5nZXMgfHxcclxuICAgICAgICAgICAgJ21pbWUnIGluIGNoYW5nZXMgfHxcclxuICAgICAgICAgICAgJ3BhZGRpbmcnIGluIGNoYW5nZXMgfHxcclxuICAgICAgICAgICAgJ3NpemUnIGluIGNoYW5nZXMgfHxcclxuICAgICAgICAgICAgJ3ZhbHVlJyBpbiBjaGFuZ2VzIHx8XHJcbiAgICAgICAgICAgICdjYW52YXMnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFFSQ29kZUNvbXBvbmVudC5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWwgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHFyID0gbmV3IFFSaW91cyh7XHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLmJhY2tncm91bmQsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQWxwaGE6IHRoaXMuYmFja2dyb3VuZEFscGhhLFxyXG4gICAgICAgICAgICAgICAgZm9yZWdyb3VuZDogdGhpcy5mb3JlZ3JvdW5kLFxyXG4gICAgICAgICAgICAgICAgZm9yZWdyb3VuZEFscGhhOiB0aGlzLmZvcmVncm91bmRBbHBoYSxcclxuICAgICAgICAgICAgICAgIGxldmVsOiB0aGlzLmxldmVsLFxyXG4gICAgICAgICAgICAgICAgbWltZTogdGhpcy5taW1lLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQocXIuY2FudmFzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHFyLmltYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGdlbmVyYXRlIFFSIENvZGU6IFwiICsgZS5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFFSQ29kZUNvbXBvbmVudDtcclxufSgpKTtcclxuUVJDb2RlQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50LCBhcmdzOiBbe1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6ICdtb2R1bGUuaWQnLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdxci1jb2RlJyxcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIlwiXHJcbiAgICAgICAgICAgIH0sXSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcblFSQ29kZUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxyXG5dOyB9O1xyXG5RUkNvZGVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XHJcbiAgICAnYmFja2dyb3VuZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG4gICAgJ2JhY2tncm91bmRBbHBoYSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG4gICAgJ2ZvcmVncm91bmQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxuICAgICdmb3JlZ3JvdW5kQWxwaGEnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxuICAgICdsZXZlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG4gICAgJ21pbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxuICAgICdwYWRkaW5nJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbiAgICAnc2l6ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG4gICAgJ3ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbiAgICAnY2FudmFzJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbn07XHJcbnZhciBRUkNvZGVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUVJDb2RlTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFFSQ29kZU1vZHVsZTtcclxufSgpKTtcclxuUVJDb2RlTW9kdWxlLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbUVJDb2RlQ29tcG9uZW50XSxcclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1FSQ29kZUNvbXBvbmVudF1cclxuICAgICAgICAgICAgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuUVJDb2RlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG5cbi8qKlxyXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cclxuICovXG5cbmV4cG9ydHMuUVJDb2RlQ29tcG9uZW50ID0gUVJDb2RlQ29tcG9uZW50O1xuZXhwb3J0cy5RUkNvZGVNb2R1bGUgPSBRUkNvZGVNb2R1bGU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXX0=