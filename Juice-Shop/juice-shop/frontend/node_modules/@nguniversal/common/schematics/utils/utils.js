/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/common/schematics/utils/utils", ["require", "exports", "@angular-devkit/schematics", "@schematics/angular/utility/workspace", "typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addInitialNavigation = exports.getImportOfIdentifier = exports.findImport = exports.getOutputPath = exports.stripTsExtension = exports.getProject = void 0;
    const schematics_1 = require("@angular-devkit/schematics");
    const workspace_1 = require("@schematics/angular/utility/workspace");
    const ts = require("typescript");
    function getProject(host, projectName) {
        return __awaiter(this, void 0, void 0, function* () {
            const workspace = yield workspace_1.getWorkspace(host);
            const project = workspace.projects.get(projectName);
            if (!project || project.extensions.projectType !== 'application') {
                throw new schematics_1.SchematicsException(`Universal requires a project type of 'application'.`);
            }
            return project;
        });
    }
    exports.getProject = getProject;
    function stripTsExtension(file) {
        return file.replace(/\.ts$/, '');
    }
    exports.stripTsExtension = stripTsExtension;
    function getOutputPath(host, projectName, target) {
        return __awaiter(this, void 0, void 0, function* () {
            // Generate new output paths
            const project = yield getProject(host, projectName);
            const serverTarget = project.targets.get(target);
            if (!serverTarget || !serverTarget.options) {
                throw new schematics_1.SchematicsException(`Cannot find 'options' for ${projectName} ${target} target.`);
            }
            const { outputPath } = serverTarget.options;
            if (typeof outputPath !== 'string') {
                throw new schematics_1.SchematicsException(`outputPath for ${projectName} ${target} target is not a string.`);
            }
            return outputPath;
        });
    }
    exports.getOutputPath = getOutputPath;
    function findImport(sourceFile, moduleName, symbolName) {
        // Only look through the top-level imports.
        for (const node of sourceFile.statements) {
            if (!ts.isImportDeclaration(node) || !ts.isStringLiteral(node.moduleSpecifier) ||
                node.moduleSpecifier.text !== moduleName) {
                continue;
            }
            const namedBindings = node.importClause && node.importClause.namedBindings;
            if (!namedBindings || !ts.isNamedImports(namedBindings)) {
                continue;
            }
            if (namedBindings.elements.some(element => element.name.text === symbolName)) {
                return namedBindings;
            }
        }
        return null;
    }
    exports.findImport = findImport;
    /** Gets import information about the specified identifier by using the Type checker. */
    function getImportOfIdentifier(typeChecker, node) {
        const symbol = typeChecker.getSymbolAtLocation(node);
        if (!symbol || !symbol.declarations.length) {
            return null;
        }
        const decl = symbol.declarations[0];
        if (!ts.isImportSpecifier(decl)) {
            return null;
        }
        const importDecl = decl.parent.parent.parent;
        if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {
            return null;
        }
        return {
            // Handles aliased imports: e.g. "import {Component as myComp} from ...";
            name: decl.propertyName ? decl.propertyName.text : decl.name.text,
            importModule: importDecl.moduleSpecifier.text,
            node: importDecl
        };
    }
    exports.getImportOfIdentifier = getImportOfIdentifier;
    function addInitialNavigation(node) {
        const existingOptions = node.arguments[1];
        // If the user has explicitly set initialNavigation, we respect that
        if (existingOptions && existingOptions.properties.some(exp => ts.isPropertyAssignment(exp) && ts.isIdentifier(exp.name) &&
            exp.name.text === 'initialNavigation')) {
            return node;
        }
        const enabledLiteral = ts.createStringLiteral('enabled');
        // TypeScript will emit the Node with double quotes.
        // In schematics we usually write code with a single quotes
        // tslint:disable-next-line: no-any
        enabledLiteral.singleQuote = true;
        const initialNavigationProperty = ts.createPropertyAssignment('initialNavigation', enabledLiteral);
        const routerOptions = existingOptions
            ? ts.updateObjectLiteral(existingOptions, ts.createNodeArray([
                ...existingOptions.properties,
                initialNavigationProperty
            ]))
            : ts.createObjectLiteral([initialNavigationProperty], true);
        const args = [node.arguments[0], routerOptions];
        return ts.createCall(node.expression, node.typeArguments, args);
    }
    exports.addInitialNavigation = addInitialNavigation;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2NvbW1vbi9zY2hlbWF0aWNzL3V0aWxzL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUdILDJEQUFpRTtJQUVqRSxxRUFBcUU7SUFDckUsaUNBQWlDO0lBRWpDLFNBQXNCLFVBQVUsQ0FDOUIsSUFBVSxFQUNWLFdBQW1COztZQUVuQixNQUFNLFNBQVMsR0FBRyxNQUFNLHdCQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0MsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7WUFFcEQsSUFBSSxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLFdBQVcsS0FBSyxhQUFhLEVBQUU7Z0JBQ2hFLE1BQU0sSUFBSSxnQ0FBbUIsQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO2FBQ3RGO1lBRUQsT0FBTyxPQUFPLENBQUM7UUFDakIsQ0FBQztLQUFBO0lBWkQsZ0NBWUM7SUFFRCxTQUFnQixnQkFBZ0IsQ0FBQyxJQUFZO1FBQzNDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUZELDRDQUVDO0lBRUQsU0FBc0IsYUFBYSxDQUNqQyxJQUFVLEVBQ1YsV0FBbUIsRUFDbkIsTUFBMEI7O1lBRTFCLDRCQUE0QjtZQUM1QixNQUFNLE9BQU8sR0FBRyxNQUFNLFVBQVUsQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDcEQsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDakQsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUU7Z0JBQzFDLE1B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RSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1lBQ3pELEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLG1CQUFtQixDQUFDLEVBQUU7WUFDeEMsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELE1BQU0sY0FBYyxHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN6RCxvREFBb0Q7UUFDcEQsMkRBQTJEO1FBQzNELG1DQUFtQztRQUNsQyxjQUFzQixDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFFM0MsTUFBTSx5QkFBeUIsR0FDM0IsRUFBRSxDQUFDLHdCQUF3QixDQUFDLG1CQUFtQixFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ3JFLE1BQU0sYUFBYSxHQUFHLGVBQWU7WUFDbkMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDLGVBQWUsQ0FBQztnQkFDM0QsR0FBRyxlQUFlLENBQUMsVUFBVTtnQkFDN0IseUJBQXlCO2FBQzFCLENBQUMsQ0FBQztZQUNILENBQUMsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsQ0FBQyx5QkFBeUIsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzlELE1BQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQztRQUVoRCxPQUFPLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUEzQkQsb0RBMkJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7IHdvcmtzcGFjZXMgfSBmcm9tICdAYW5ndWxhci1kZXZraXQvY29yZSc7XG5pbXBvcnQgeyBTY2hlbWF0aWNzRXhjZXB0aW9uIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L3NjaGVtYXRpY3MnO1xuaW1wb3J0IHsgVHJlZSB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9zY2hlbWF0aWNzL3NyYy90cmVlL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBnZXRXb3Jrc3BhY2UgfSBmcm9tICdAc2NoZW1hdGljcy9hbmd1bGFyL3V0aWxpdHkvd29ya3NwYWNlJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvamVjdChcbiAgaG9zdDogVHJlZSxcbiAgcHJvamVjdE5hbWU6IHN0cmluZyxcbik6IFByb21pc2U8d29ya3NwYWNlcy5Qcm9qZWN0RGVmaW5pdGlvbj4ge1xuICBjb25zdCB3b3Jrc3BhY2UgPSBhd2FpdCBnZXRXb3Jrc3BhY2UoaG9zdCk7XG4gIGNvbnN0IHByb2plY3QgPSB3b3Jrc3BhY2UucHJvamVjdHMuZ2V0KHByb2plY3ROYW1lKTtcblxuICBpZiAoIXByb2plY3QgfHwgcHJvamVjdC5leHRlbnNpb25zLnByb2plY3RUeXBlICE9PSAnYXBwbGljYXRpb24nKSB7XG4gICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb24oYFVuaXZlcnNhbCByZXF1aXJlcyBhIHByb2plY3QgdHlwZSBvZiAnYXBwbGljYXRpb24nLmApO1xuICB9XG5cbiAgcmV0dXJuIHByb2plY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFRzRXh0ZW5zaW9uKGZpbGU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBmaWxlLnJlcGxhY2UoL1xcLnRzJC8sICcnKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE91dHB1dFBhdGgoXG4gIGhvc3Q6IFRyZWUsXG4gIHByb2plY3ROYW1lOiBzdHJpbmcsXG4gIHRhcmdldDogJ3NlcnZlcicgfCAnYnVpbGQnLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgLy8gR2VuZXJhdGUgbmV3IG91dHB1dCBwYXRoc1xuICBjb25zdCBwcm9qZWN0ID0gYXdhaXQgZ2V0UHJvamVjdChob3N0LCBwcm9qZWN0TmFtZSk7XG4gIGNvbnN0IHNlcnZlclRhcmdldCA9IHByb2plY3QudGFyZ2V0cy5nZXQodGFyZ2V0KTtcbiAgaWYgKCFzZXJ2ZXJUYXJnZXQgfHwgIXNlcnZlclRhcmdldC5vcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb25cbiAgICAgIChgQ2Fubm90IGZpbmQgJ29wdGlvbnMnIGZvciAke3Byb2plY3ROYW1lfSAke3RhcmdldH0gdGFyZ2V0LmApO1xuICB9XG5cbiAgY29uc3QgeyBvdXRwdXRQYXRoIH0gPSBzZXJ2ZXJUYXJnZXQub3B0aW9ucztcbiAgaWYgKHR5cGVvZiBvdXRwdXRQYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBTY2hlbWF0aWNzRXhjZXB0aW9uXG4gICAgICAoYG91dHB1dFBhdGggZm9yICR7cHJvamVjdE5hbWV9ICR7dGFyZ2V0fSB0YXJnZXQgaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dFBhdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW1wb3J0KHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOYW1lOiBzdHJpbmcpOiB0cy5OYW1lZEltcG9ydHMgfCBudWxsIHtcbiAgLy8gT25seSBsb29rIHRocm91Z2ggdGhlIHRvcC1sZXZlbCBpbXBvcnRzLlxuICBmb3IgKGNvbnN0IG5vZGUgb2Ygc291cmNlRmlsZS5zdGF0ZW1lbnRzKSB7XG4gICAgaWYgKCF0cy5pc0ltcG9ydERlY2xhcmF0aW9uKG5vZGUpIHx8ICF0cy5pc1N0cmluZ0xpdGVyYWwobm9kZS5tb2R1bGVTcGVjaWZpZXIpIHx8XG4gICAgICBub2RlLm1vZHVsZVNwZWNpZmllci50ZXh0ICE9PSBtb2R1bGVOYW1lKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lZEJpbmRpbmdzID0gbm9kZS5pbXBvcnRDbGF1c2UgJiYgbm9kZS5pbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncztcblxuICAgIGlmICghbmFtZWRCaW5kaW5ncyB8fCAhdHMuaXNOYW1lZEltcG9ydHMobmFtZWRCaW5kaW5ncykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lZEJpbmRpbmdzLmVsZW1lbnRzLnNvbWUoZWxlbWVudCA9PiBlbGVtZW50Lm5hbWUudGV4dCA9PT0gc3ltYm9sTmFtZSkpIHtcbiAgICAgIHJldHVybiBuYW1lZEJpbmRpbmdzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBJbXBvcnQgPSB7XG4gIG5hbWU6IHN0cmluZyxcbiAgaW1wb3J0TW9kdWxlOiBzdHJpbmcsXG4gIG5vZGU6IHRzLkltcG9ydERlY2xhcmF0aW9uXG59O1xuXG4vKiogR2V0cyBpbXBvcnQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNwZWNpZmllZCBpZGVudGlmaWVyIGJ5IHVzaW5nIHRoZSBUeXBlIGNoZWNrZXIuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1wb3J0T2ZJZGVudGlmaWVyKHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogdHMuSWRlbnRpZmllcik6IEltcG9ydCB8IG51bGwge1xuICBjb25zdCBzeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5vZGUpO1xuXG4gIGlmICghc3ltYm9sIHx8ICFzeW1ib2wuZGVjbGFyYXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZGVjbCA9IHN5bWJvbC5kZWNsYXJhdGlvbnNbMF07XG5cbiAgaWYgKCF0cy5pc0ltcG9ydFNwZWNpZmllcihkZWNsKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgaW1wb3J0RGVjbCA9IGRlY2wucGFyZW50LnBhcmVudC5wYXJlbnQ7XG5cbiAgaWYgKCF0cy5pc1N0cmluZ0xpdGVyYWwoaW1wb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIEhhbmRsZXMgYWxpYXNlZCBpbXBvcnRzOiBlLmcuIFwiaW1wb3J0IHtDb21wb25lbnQgYXMgbXlDb21wfSBmcm9tIC4uLlwiO1xuICAgIG5hbWU6IGRlY2wucHJvcGVydHlOYW1lID8gZGVjbC5wcm9wZXJ0eU5hbWUudGV4dCA6IGRlY2wubmFtZS50ZXh0LFxuICAgIGltcG9ydE1vZHVsZTogaW1wb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIudGV4dCxcbiAgICBub2RlOiBpbXBvcnREZWNsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRJbml0aWFsTmF2aWdhdGlvbihub2RlOiB0cy5DYWxsRXhwcmVzc2lvbik6IHRzLkNhbGxFeHByZXNzaW9uIHtcbiAgY29uc3QgZXhpc3RpbmdPcHRpb25zID0gbm9kZS5hcmd1bWVudHNbMV0gYXMgdHMuT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24gfCB1bmRlZmluZWQ7XG5cbiAgLy8gSWYgdGhlIHVzZXIgaGFzIGV4cGxpY2l0bHkgc2V0IGluaXRpYWxOYXZpZ2F0aW9uLCB3ZSByZXNwZWN0IHRoYXRcbiAgaWYgKGV4aXN0aW5nT3B0aW9ucyAmJiBleGlzdGluZ09wdGlvbnMucHJvcGVydGllcy5zb21lKGV4cCA9PlxuICAgIHRzLmlzUHJvcGVydHlBc3NpZ25tZW50KGV4cCkgJiYgdHMuaXNJZGVudGlmaWVyKGV4cC5uYW1lKSAmJlxuICAgIGV4cC5uYW1lLnRleHQgPT09ICdpbml0aWFsTmF2aWdhdGlvbicpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBjb25zdCBlbmFibGVkTGl0ZXJhbCA9IHRzLmNyZWF0ZVN0cmluZ0xpdGVyYWwoJ2VuYWJsZWQnKTtcbiAgLy8gVHlwZVNjcmlwdCB3aWxsIGVtaXQgdGhlIE5vZGUgd2l0aCBkb3VibGUgcXVvdGVzLlxuICAvLyBJbiBzY2hlbWF0aWNzIHdlIHVzdWFsbHkgd3JpdGUgY29kZSB3aXRoIGEgc2luZ2xlIHF1b3Rlc1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxuICAoZW5hYmxlZExpdGVyYWwgYXMgYW55KS5zaW5nbGVRdW90ZSA9IHRydWU7XG5cbiAgY29uc3QgaW5pdGlhbE5hdmlnYXRpb25Qcm9wZXJ0eVxuICAgID0gdHMuY3JlYXRlUHJvcGVydHlBc3NpZ25tZW50KCdpbml0aWFsTmF2aWdhdGlvbicsIGVuYWJsZWRMaXRlcmFsKTtcbiAgY29uc3Qgcm91dGVyT3B0aW9ucyA9IGV4aXN0aW5nT3B0aW9uc1xuICAgID8gdHMudXBkYXRlT2JqZWN0TGl0ZXJhbChleGlzdGluZ09wdGlvbnMsIHRzLmNyZWF0ZU5vZGVBcnJheShbXG4gICAgICAuLi5leGlzdGluZ09wdGlvbnMucHJvcGVydGllcyxcbiAgICAgIGluaXRpYWxOYXZpZ2F0aW9uUHJvcGVydHlcbiAgICBdKSlcbiAgICA6IHRzLmNyZWF0ZU9iamVjdExpdGVyYWwoW2luaXRpYWxOYXZpZ2F0aW9uUHJvcGVydHldLCB0cnVlKTtcbiAgY29uc3QgYXJncyA9IFtub2RlLmFyZ3VtZW50c1swXSwgcm91dGVyT3B0aW9uc107XG5cbiAgcmV0dXJuIHRzLmNyZWF0ZUNhbGwobm9kZS5leHByZXNzaW9uLCBub2RlLnR5cGVBcmd1bWVudHMsIGFyZ3MpO1xufVxuIl19